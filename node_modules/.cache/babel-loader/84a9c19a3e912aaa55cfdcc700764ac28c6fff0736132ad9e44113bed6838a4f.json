{"ast":null,"code":"const BASE_URL = process.env.REACT_APP_BASE_URL;\nconst CLIENT_ID = process.env.REACT_APP_API_KEY;\nconst REDIRECT_URI = process.env.REACT_APP_REDIRECT_URL;\nconst LOCAL_STORAGE_KEY = 'accessToken';\nconst storeAccessToken = (accessToken, ttl) => {\n  const now = new Date();\n  const item = {\n    value: accessToken,\n    expiry: now.getTime() + ttl * 1000\n  };\n  localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(item));\n};\nconst getStoredAccessToken = () => {\n  const itemStr = localStorage.getItem(LOCAL_STORAGE_KEY);\n  if (!itemStr) return false;\n  const item = JSON.parse(itemStr);\n  const now = new Date();\n  if (now.getTime() > item.expiry) {\n    // If the item is expired, delete the item from storage\n    // and return false\n    localStorage.removeItem(LOCAL_STORAGE_KEY);\n    return false;\n  }\n  return item.value;\n};\nconst getAccessToken = () => {\n  if (this.getStoredAccessToken()) {\n    return this.getStoredAccessToken();\n  }\n  const accessTokenMatch = window.location.href.match(/access_token=([^&]*)/);\n  const expiresInMatch = window.location.href.match(/expires_in=([^&]*)/);\n  if (accessTokenMatch && expiresInMatch) {\n    const expiresIn = Number(expiresInMatch[1]);\n    this.storeAccessToken(accessTokenMatch[1], expiresIn);\n    window.history.pushState(\"Access Token\", null, \"/\");\n    return this.getStoredAccessToken();\n  } else {\n    const accessUrl = `https://accounts.spotify.com/authorize?client_id=${CLIENT_ID}&response_type=token&scope=playlist-modify-public&redirect_uri=${REDIRECT_URI}`;\n    window.location = accessUrl;\n    return false;\n  }\n};\nasync function search(term) {\n  try {\n    const accessToken = this.getAccessToken();\n    if (accessToken) {\n      const response = await fetch(`${BASE_URL}/v1/search?type=[\"album\", \"artist\", \"playlist\", \"track\", \"show\", \"episode\", \"audiobook\"]&q=${term}`, {\n        headers: {\n          Authorization: `Bearer ${accessToken}`\n        }\n      });\n      const jsonResponse = await response.json();\n      if (!jsonResponse.tracks) {\n        return [];\n      }\n      return jsonResponse.tracks.items.map(track => ({\n        id: track.id,\n        name: track.name,\n        artist: track.artists[0].name,\n        album: track.album.name,\n        uri: track.uri\n      }));\n    }\n  } catch (e) {\n    console.error('Error fetching data:', e);\n    return []; // Return an empty array in case of an error\n  }\n}\nconst savePlaylist = async (playlistName, trackUris) => {\n  if (playlistName && trackUris) {\n    let response, jsonResponse;\n    const accessToken = this.getAccessToken();\n    const headers = {\n      Authorization: `Bearer ${accessToken}`\n    };\n    //Get userID\n    let userId;\n    response = await fetch(`${BASE_URL}/v1/me`, {\n      headers: headers\n    });\n    jsonResponse = await response.json();\n    userId = jsonResponse.id;\n\n    //Create Playlist and get its Id\n    response = await fetch(`${BASE_URL}/v1/users/${userId}/playlists`, {\n      headers: headers,\n      method: \"POST\",\n      body: JSON.stringify({\n        name: playlistName\n      })\n    });\n    jsonResponse = await response.json();\n    const playlistId = jsonResponse.id;\n\n    //Save tracks to the newly created playlist\n    response = await fetch(`${BASE_URL}/v1/users/${userId}/playlists/${playlistId}/tracks`, {\n      headers: headers,\n      method: \"POST\",\n      body: JSON.stringify({\n        uris: trackUris\n      })\n    });\n    return await response.json();\n  }\n  return;\n};\nmodule.exports = {\n  search\n};","map":{"version":3,"names":["BASE_URL","process","env","REACT_APP_BASE_URL","CLIENT_ID","REACT_APP_API_KEY","REDIRECT_URI","REACT_APP_REDIRECT_URL","LOCAL_STORAGE_KEY","storeAccessToken","accessToken","ttl","now","Date","item","value","expiry","getTime","localStorage","setItem","JSON","stringify","getStoredAccessToken","itemStr","getItem","parse","removeItem","getAccessToken","accessTokenMatch","window","location","href","match","expiresInMatch","expiresIn","Number","history","pushState","accessUrl","search","term","response","fetch","headers","Authorization","jsonResponse","json","tracks","items","map","track","id","name","artist","artists","album","uri","e","console","error","savePlaylist","playlistName","trackUris","userId","method","body","playlistId","uris","module","exports"],"sources":["C:/Users/AsusVivoBooK/Desktop/React apps/jammming/src/utils/Spotify.js"],"sourcesContent":["const BASE_URL = process.env.REACT_APP_BASE_URL;\r\nconst CLIENT_ID = process.env.REACT_APP_API_KEY;\r\nconst REDIRECT_URI = process.env.REACT_APP_REDIRECT_URL;\r\nconst LOCAL_STORAGE_KEY = 'accessToken';\r\n\r\nconst storeAccessToken = (accessToken, ttl) => {\r\n    const now = new Date();\r\n\r\n    const item = {\r\n        value: accessToken,\r\n        expiry: now.getTime() + ttl * 1000\r\n    }\r\n    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(item))\r\n}\r\n\r\nconst getStoredAccessToken = () => {\r\n    const itemStr = localStorage.getItem(LOCAL_STORAGE_KEY);\r\n\r\n    if (!itemStr)\r\n        return false;\r\n\r\n    const item = JSON.parse(itemStr);\r\n    const now = new Date();\r\n\r\n    if (now.getTime() > item.expiry) {\r\n        // If the item is expired, delete the item from storage\r\n        // and return false\r\n        localStorage.removeItem(LOCAL_STORAGE_KEY);\r\n        return false;\r\n    }\r\n    return item.value;\r\n}\r\n\r\nconst getAccessToken = () => {\r\n    if (this.getStoredAccessToken()) {\r\n        return this.getStoredAccessToken()\r\n    }\r\n\r\n    const accessTokenMatch = window.location.href.match(/access_token=([^&]*)/);\r\n    const expiresInMatch = window.location.href.match(/expires_in=([^&]*)/);\r\n    if (accessTokenMatch && expiresInMatch) {\r\n        const expiresIn = Number(expiresInMatch[1]);\r\n        this.storeAccessToken(accessTokenMatch[1], expiresIn);\r\n        window.history.pushState(\"Access Token\", null, \"/\");\r\n        return this.getStoredAccessToken();\r\n    } else {\r\n        const accessUrl = `https://accounts.spotify.com/authorize?client_id=${CLIENT_ID}&response_type=token&scope=playlist-modify-public&redirect_uri=${REDIRECT_URI}`;\r\n        window.location = accessUrl;\r\n        return false;\r\n    }\r\n}\r\n\r\nasync function search(term) {\r\n    try {\r\n        const accessToken = this.getAccessToken();\r\n\r\n        if (accessToken) {\r\n            const response = await fetch(\r\n                `${BASE_URL}/v1/search?type=[\"album\", \"artist\", \"playlist\", \"track\", \"show\", \"episode\", \"audiobook\"]&q=${term}`,\r\n                {\r\n                    headers: {\r\n                        Authorization: `Bearer ${accessToken}`\r\n                    }\r\n                }\r\n            )\r\n\r\n            const jsonResponse = await response.json();\r\n            if (!jsonResponse.tracks) {\r\n                return [];\r\n            }\r\n\r\n            return jsonResponse.tracks.items.map((track) => ({\r\n                id: track.id,\r\n                name: track.name,\r\n                artist: track.artists[0].name,\r\n                album: track.album.name,\r\n                uri: track.uri,\r\n            }));\r\n        }\r\n\r\n    } catch (e) {\r\n        console.error('Error fetching data:', e);\r\n        return []; // Return an empty array in case of an error\r\n    }\r\n}\r\n\r\nconst savePlaylist = async (playlistName, trackUris) => {\r\n    if (playlistName && trackUris) {\r\n        let response, jsonResponse;\r\n        const accessToken = this.getAccessToken();\r\n        const headers = {\r\n            Authorization: `Bearer ${accessToken}`,\r\n        };\r\n        //Get userID\r\n        let userId;\r\n        response = await fetch(`${BASE_URL}/v1/me`, {\r\n            headers: headers,\r\n        });\r\n        jsonResponse = await response.json();\r\n        userId = jsonResponse.id;\r\n\r\n        //Create Playlist and get its Id\r\n        response = await fetch(\r\n            `${BASE_URL}/v1/users/${userId}/playlists`,\r\n            {\r\n                headers: headers,\r\n                method: \"POST\",\r\n                body: JSON.stringify({ name: playlistName }),\r\n            }\r\n        );\r\n        jsonResponse = await response.json();\r\n        const playlistId = jsonResponse.id;\r\n\r\n        //Save tracks to the newly created playlist\r\n        response = await fetch(\r\n            `${BASE_URL}/v1/users/${userId}/playlists/${playlistId}/tracks`,\r\n            {\r\n                headers: headers,\r\n                method: \"POST\",\r\n                body: JSON.stringify({ uris: trackUris }),\r\n            }\r\n        );\r\n        return await response.json();\r\n    }\r\n    return;\r\n}\r\n\r\nmodule.exports = { search };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}