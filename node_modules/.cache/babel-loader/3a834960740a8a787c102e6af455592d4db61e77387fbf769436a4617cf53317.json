{"ast":null,"code":"'use strict';\n\nvar callBind = require('call-bind');\nvar callBound = require('call-bind/callBound');\nvar GetIntrinsic = require('get-intrinsic');\nvar $ArrayBuffer = GetIntrinsic('%ArrayBuffer%', true);\n/** @type {undefined | ((receiver: ArrayBuffer) => number) | ((receiver: unknown) => never)} */\nvar $byteLength = callBound('ArrayBuffer.prototype.byteLength', true);\nvar $toString = callBound('Object.prototype.toString');\n\n// in node 0.10, ArrayBuffers have no prototype methods, but have an own slot-checking `slice` method\nvar abSlice = !!$ArrayBuffer && !$byteLength && new $ArrayBuffer(0).slice;\nvar $abSlice = !!abSlice && callBind(abSlice);\n\n/** @type {import('.')} */\nmodule.exports = $byteLength || $abSlice ? function isArrayBuffer(obj) {\n  if (!obj || typeof obj !== 'object') {\n    return false;\n  }\n  try {\n    if ($byteLength) {\n      // @ts-expect-error no idea why TS can't handle the overload\n      $byteLength(obj);\n    } else {\n      // @ts-expect-error TS chooses not to type-narrow inside a closure\n      $abSlice(obj, 0);\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n} : $ArrayBuffer\n// in node 0.8, ArrayBuffers have no prototype or own methods, but also no Symbol.toStringTag\n? function isArrayBuffer(obj) {\n  return $toString(obj) === '[object ArrayBuffer]';\n} : function isArrayBuffer(obj) {\n  // eslint-disable-line no-unused-vars\n  return false;\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}